#面试常考算法

##基础
单链表、双循环链表、队列、大根堆、小根堆、栈；

字符串常用函数的源码实现，如：strcpy、strncpy、strcmp、strncmp、strcat、strlen、
strchr、strrchr;

原型size_t strspn(const char *pstr, const char *strCharset)
功能：返回后面字符串中第一个不在前者出现的下标。
 
strcspn
原型：size_t strcspn(const char *pstr, const char *strCharset)
MSDN解释为：在字符串pstr中搜寻strCharsret中所出现的字符，返回strCharset中出现的第一个字符在pstr中的出现位置。简单的说，若strcspn返回的数值为n，则代表字符串strCharsrt开头连续有n个字符不包含在pstr内的字符。

[strcspn实现十分巧妙](http://blog.csdn.net/chenyu2202863/article/details/5293941)

strdup()
此函数原型为char *strdup(const char *str)
功能为拷贝字符串到新建的内存，返回内存指针。若失败，返回NULL。要注意，返回的指针指向的内存在堆中，所以要手动释放。

    char *strdup(const char *str)  
    {  
        char *p=NULL;  
        if(str&&(p=(char*)malloc(strlen(str)+1)))  
            strcpy(ptr);  
        return p;
    }

strrev()
此函数的原型为char *strrev(char *str)
功能为反转字符串，返回字符串指针。

    char *strrev(char *str)  
    {  
        if(str==NULL)  
            return NULL;  
        char *start=str;  
        char *end=str+strlen(str)-1;  
        char temp;  
        while(start<end)  
        {  
            temp=*start;  
            *start=*end;  
            *end=temp;  
            start++;  
            end--;  
        }  
        return str;  
    }  

strstr()
函数原型为char *strstr(const char str1, const char *str2)
功能为查找字符串str2在str1中出现的位置，找到则返回位置，否则返回NULL。

    char *strstr(const char str1, const char *str2)  
    {  
        int length1=strlen(str1);  
        int length2=strlen(str2);  
        while(length1>=length2)  
        {  
            length1--;  
            if(!strncpy(str1tr2,length2))//比较前n个字符串，类似strcpy  
                return str1;  
            str1++;  
        }  
        return NULL;  
    }  
内存常用的几个函数源码实现，如：memcpy、memmove、memset、memcmp、memicmp、memchr；
这几个函数在二线，三线企业面试很常见！

排序算法（按照以往学生面试被问到反馈的顺序）：快速排序、堆排序、归并排序、选择排序、字典排序、插入排序、
冒泡排序、计数排序、基数排序、桶排序、希尔排序、拓扑排序;
[九大基础排序总结与对比](http://blog.csdn.net/amazing7/article/details/51603682)

##中级
二叉树、T树、自平衡二叉查找树、平衡树、树的前中后序遍历的非递归实现、B+树、B-树、B*树、有向图、无向图、深度广度遍历、最短路径、HashMap、HashTable、
ConcurrentHashmap、TreeMap、HashSet、Set、MultiSet、Map、MultiMap;
##高级
字典树，线段树，伸展树、Treap树, 红黑树；

###五花八门树(有兴趣可以了解一下)
>前缀树、后缀树、基数树、四叉树、八叉树、k-d树、vp-树
>R树、R*树、R+树、X树
>M树、希尔伯特R树、优先R树
>
>Exponential TreeMap、 Fusion TreeMap、 区间树、 PQ tree
>、 Range tree、 SPQR tree、 Van Emde Boas tree
>Cover tree、 BK-tree、 Doubly-chained tree

并查集；
跳跃表；
redis跳跃表；
redis压缩链表(ziplist)；

蚁群算法(ant colony optimization,
ACO)，又称蚂蚁算法，是一种用来在图中寻找优化路径的机率型算法；

遗传算法，模拟退火算法、禁忌搜索算法、粒子群算法，动态规定算法，回溯法和分支限界法；

##扩展

###压缩算法：

>GZIP、LZO、Zippy/Snappy、Zlib、LZ4；

BigTable和HBase中压缩算法的选择
BigTable中采用的是Zippy算法，目标是达到尽可能快的压缩和解压速度，同时减少对CPU的消耗。

HBase中，在Snappy发布之前（Google2011年对外发布Snappy），采用的LZO算法，目标和BigTable类似；在Snappy发布之后，建议采用Snappy算法，具体可以根据实际情况对LZO和Snappy做过更详细的对比测试后再做选择。

MongoDB(NoSQL领域的No.1)推荐选用Snappy。

Kafka（分布式海量高性能消息队列首选）支持Snappy、Zlib。

MySQL内置zlib压缩算法；

###其他压缩算法
>LZ77、RLE、HaffMan、字典算法、固定位长算法（Fixed Bit Length
>Packing）、Lzham、QuickLZ

###加密算法

###增量上传/下载

##海量数据
##企业级别
##
##
##
##
##面试必看书籍

剑指offer、编程之美（推荐指数99）；

算法导论、编程珠玑（喜欢研究算法的同学就有福气了，面试推荐指数85）；









